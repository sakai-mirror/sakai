Incremental Component Development in JSF

Once JSP 2 compatibility is achieved, I anticipate a very reasonable incremental development process on the presentation side:

  1) Application developers (including UI designers) encode page-specific formatting (i.e., not covered by an existing JSF tag) in place.

  2) The second time the formatting is needed, it gets extracted to an included fragment rather than copied-pasted-and-modified.

  3) If the fragment is not static (e.g., it requires runtime parameters), it gets turned into an application-specific web-specific component via a low-overhead JSP tag: typically one simple file.

  4) If that component is of potential use to other Sakai tools, it feeds into the Style Guide and gets turned into a full-fledged general-purpose (but much higher overhead) JSF tag: typically three Java classes (one of them a fairly complex renderer, since the JSF class hierarchy doesn't do a good job of promoting code re-use), and one XML file.

Without JSP 2 compatibility, incremental development now has to take an uncomfortably big step from (2) to (4).

Here are ways I've seen developers avoid or postpone that step in JSF 1.1.

1) Use Tiles for layout.

	Although JSF and Struts aren't that attractive a combination, JSF and Tiles seem fairly popular, particularly when MyFaces is used as a JSF platform. Tiles provides a clear description of HTML fragment layout, including attribute arguments.

	Tiles integration is discussed in the O'Reilly book, recommended in Sun's "Core JavaServer Faces" book (<http://www.artima.com/chapters/book.jsp?num=59362>), and used in sample applications from MyFaces, JDJ (<http://sys-con.com/story/?storyid=46977&DE=1>), Exadel (<http://forum.exadel.com/viewtopic.php?t=968>), and IBM (<http://www-106.ibm.com/developerworks/java/library/j-integrate/>).

2) Use a templating ViewHandler for slightly Tapestry-like development acceleration.

	Actually, I don't know of anyone doing this for real, but Hans Bergsten ("JavaServer Faces" author) has been plugging the idea for a while.

3) Use JSP 2 dynamic includes, despite the incompatibility with JSF 1.1.

	Static inclusion simply glues static JSP fragments together, with no concept of parameters being passed into the fragments. Dynamic inclusion runs a new request to interpret the included fragment on its way into the surrounding page. In JSP 2, parameters can be passed to the included JSP file.

	This is the simplest first step towards a UI component. Its performance is noticeably poor due to the extra request, but would be acceptable for prototyping and early testing.

	To use with JSF, the inclusion instruction must be put inside a subview:

		<f:subview id="testJsp2Include">
			<jsp:include page="testJsp2Include.jsp" flush="true">
	 			<jsp:param name="currentAppContext" value="overview"/>
			</jsp:include>
		</f:subview>

	The included JSP 2 code can refer to the input parameters and to JSF backing beans. JSF tags have no way to access the parameters.

		<f:verbatim>
		<h1><%=request.getParameter("currentAppContext") %> is current</h1>
		<h2>JSP EL param: ${param.currentAppContext}</h2>
		<h3>gradebooks: ${sessionScope.testGradebookTool.gradebooks}</h3>
		</f:verbatim>

		<!-- None of the following find anything. -->
		<h:outputText value="param: #{param[currentAppContext]}, "/>
		<h:outputText value="param.: #{param.currentAppContext}, "/>
		<h:outputText value="paramValues: #{paramValues[currentAppContext][0]}, "/>
		<h:outputText value="requestScope: #{requestScope[currentAppContext]}, "/>
		<h:outputText value="initParam: #{initParam[currentAppContext]}"/>

4) Use JSP 2 tags, despite the incompatibility with JSF 1.1.

	In JSP 2, simple tags can actually be defined using JSP. Such tags are more powerful and efficient than dynamic inclusion, and aren't all that much more complex than dynamic inclusion would be. A tags library location has to be specified in the including JSP:

		<%@ taglib prefix="tags" tagdir="/WEB-INF/tags" %>

		<tags:testJsp2Tag activeMenuItem="roster">
			<!--
				A bunch of HTML, JSP, and JSF code could go in here, and
				then be processed inside the tag file via "jsp:doBody".
			-->
		</tags:testJsp2Tag>

	Here's a corresponding "tags/testJsp2Tag.tag" file:

		<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>
		<%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>
		<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

		<%@ attribute name="activeMenuItem" %>

		<f:verbatim>
		<h2>JSP attribute: ${activeMenuItem}</h2>

		<!--
			Looks like we need to explicitly useBean to let JSP set a bean property, although it can
			get a bean property just by prefixing the scope and although I've seen example code
			that claims to do it.
		-->

		<!-- Doesn't work. -->
		<!-- jsp:setProperty name="requestScope.testJsp2Bean" property="currentTask" value="${activeMenuItem}" / -->

		<!-- Doesn't work. -->
		<!-- c:set target="${requestScope.testJsp2Bean}" property="currentTask" value="${activeMenuItem}"/ -->

		<!-- Doesn't work. -->
		<!-- c:set target="${requestScope.testJsp2Bean.currentTask}" value="${activeMenuItem}"/ -->

		<!-- This works with useBean. -->
		<jsp:useBean class="org.sakaiproject.tool.gradebook.ui.TestJsp2Bean" id="testJsp2Bean" scope="request" />
		<c:set target="${testJsp2Bean}" property="currentTask" value="${activeMenuItem}" />

		<c:set var="attributeCopy" value="${activeMenuItem}" scope="session" />
		<c:set var="reqCopy" value="${activeMenuItem}" scope="request" />

		</f:verbatim>

		<!-- JSF EL can't see the attribute, even if pageScope is specified. -->
		<h:outputText value="attribute: #{activeMenuItem}, "/>
		<h:outputText value="pageScope.attribute: #{pageScope.activeMenuItem}, "/>

		<!-- However, JSF can see the modified bean property, and explicitly scoped variables other than page scope. -->
		<h:outputText value="bean.currentTask: #{testJsp2Bean.currentTask}, "/>
		<h:outputText value="sessionScope.attributeCopy: #{sessionScope.attributeCopy}, " />
		<h:outputText value="requestScope.reqCopy: #{requestScope.reqCopy}" />

	Again, JSP 2 can see JSF backing beans, but JSF can't see the tag attribute. Unfortunately, the version of JSP 2 tag libraries I tested required explicitly connecting a bean definition to a class and scope (replicating data in the JSF configuration file) to be able to *change* a backing bean property. It's probably safer (if just as redundant) to pass any data through a request scope variable.

To enable JSP 2 and its core tags, I changed the top of "web.xml" to:

	<?xml version="1.0"?>
	<web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

And added this to "gb/tool/project.xml":

	<dependency>
		<groupId>jstl</groupId>
		<artifactId>jstl</artifactId>
		<version>1.1.2</version>
		<properties>
			<war.bundle>true</war.bundle>
		</properties>
	</dependency>
	<dependency>
		<groupId>taglibs</groupId>
		<artifactId>standard</artifactId>
		<version>1.1.2</version>
		<properties>
			<war.bundle>true</war.bundle>
		</properties>
	</dependency>
