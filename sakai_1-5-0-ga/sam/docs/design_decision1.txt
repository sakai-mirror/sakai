X-Sieve: CMU Sieve 2.2 
X-Sender: esmiley@localhost (Unverified) 
X-Mailer: QUALCOMM Windows Eudora Version 5.2.0.9 
Date: Thu, 05 Aug 2004 13:51:50 -0700 
To: Chuck Severance <csev@umich.edu> 
From: Ed Smiley <esmiley@stanford.edu> 
Subject: Open Service Interface Definitions 
Cc: Rachel Gollub <rgollub@stanford.edu>;, 
        Daisy Flemming <daisyf@stanford.edu> 


Chuck,

Rachel suggested that I forward on a design that I have proposed implementing in SAM.  She suggests that this might be extremely helpful and timely in the work you are starting on Sakai Open Service Interface Definitions.  I have been working on this design in close collaboration with my colleague, Daisy Flemming, who is working on the Hibernate/Persistence layer for SAM.  

In the design, the actual application will talk to facades and will be insulated from the actual OSIDs.  We also have a set of interfaces that encapsulate our out-of-band (OOB) agreements. There will be one such interface for each OSID class in question. Each facade class will implement the corresponding OOB interface.  In our data layer each top level Hibernate/POJO will implement the corresponding interface. The facade classes will be in their own package and the application will not import any OSID classes.  The data property (getData()) of the OSID will also implement this interface.  (OKI implementation)  The facades will use the services provided by the OSIDs themselves to inject the specific implementation classes in  question.  They will implement methods generally by doing a pass-through of the data property methods.  We will also provide a reverse lookup facility for third party OSID-consuming tools to obtain the OSID implementation from its corresponding wrapper class.  This facility will not be used internally by the application, but is designed for third party tools that consume OSID services.

There are a number of advantages to this design.  We have considerable experience with implementing OKI OSIDs in a complex application environment and these ideas hopefully reflect some of that experience.  First, we have insulated the entire application from changes in the service definition, which would otherwise percolate through every nook and cranny of the code.  Second, we have defined the OOB in an interface for external OSID implementors.  This means that we have documented the OOB by encapsulating them as interfaces.  This also means that if another OSID implementation is injected into the application it will compile, and if it correctly implements the clearly defined OOB interface in its data property it will run.  Thirdly, since we provide a mechanism for external access to our internal OSID implementation, tools that consume external OSID implementations can access the standard set of OSID services that are known to be available.  Fourth, it allows the swapping of non-OKI services by rewriting the corresponding facades. 

I tried to compress these ideas for the sake of brevity.  Please feel free to ask questions and I will be happy to respond in more detail.

Yours,
Ed 



Ed Smiley
Senior Software Developer
Department:   Academic Computing 
Mail Code:   3101 
Work Address:   Meyer Library RM 260
Stanford, California, 94305 
esmiley@stanford.edu 
