

                              Structuring Sakai


                               Glenn R. Golden
                          Sakai Framework Architect
                                July 10, 2005

This document describes the new Structure feature in Sakai 2.  We didn't
get this into the 2.0 version of Sakai; it is one of the defining features
of 2.1.

Sakai, which was once a number of disjointed flat information spaces, now
has a central structure.  The data entities that we create in Sakai, from
chat messages to gradebooks, announcement channels to hosted resources, now
are placed somewhere in this structure.  User access to Sakai is now
focused on some part of the structure.

The structure of Sakai is built up by various tools and external data to
reflect the organizational structure of the Sakai installation relevant to
the Sakai service.  Some Sakai tools directly maintain this structure;
other Sakai tools and features connect to the local enterprise's
information systems to help shape the Sakai structure.

In the process of achieving structure in Sakai, the Sakai applications went
through a process of becoming "Structure Aware".  This process is described
in the remainder of the document.  Structure awareness is a requirement of
all well integrated Sakai applications.  Even if the application does not
otherwise take advantage of the structure features of Sakai, it must be at
least minimally aware of structure to be able to take part in the Sakai
security (authorization) model.

It helps to draw structure to understand it.  Structure is represented by
nodes:

[pic]

Nodes are connected in a graph, or hierarchy; nodes can have many children,
and each node has a single parent (except for the top node in the
structure):

[pic]

Nodes have a single data entity "hanging" from it; these each has a Type:

[pic]


The Structure Context of User Navigation


Sakai applications are accessed as a result of a process of navigation
mediated by a Sakai portal.  While the navigation techniques differ between
the different portals, when the application is finally invoked, the user
has navigated to somewhere in the Sakai structure.  The user interaction
comes with a "context" that is a location, or node, in the structure.

To describe this in old familiar terms, the user has come to a class site,
or a project site, or their home space. But with the new Sakai structure,
the places where the user can be when they invoke applications are greatly
expanded.  Now they might be at the English department's node, or in a
section of a class, or at any other location in the unlimited Sakai
structure.

Wherever they are, whatever context arrives with their application
interaction requests, they will expect the application to be sensitive to
this location.  When they invoke the resources tool, they will want to see
the resources related to the location they navigated to.

This has been true in Sakai 2.0 and before, of course.  The main difference
in the context of a request is that before, it was just a string (probably
the Site id).  Now, the context of a request is a node in the Sakai
structure.

What the application does with the request context will vary.  The node
still has a "string context", in the form of a UUID, and that might be
enough.  But fully integrated applications will need the node as their
ticket to access the structures services of Sakai.


Storing Entities in the Sakai Structure


Probably the first thing an application will need to do as it becomes
structure aware is to make use of the Sakai structure when storing its
entities.  The structure does not store the data of the entity, nor does it
model the data; these responsibilities remain with the application (where
they belong!).  What the application needs to do when creating a new entity
is locate it in the Sakai structure somewhere.  The other thing the
application needs to do is register a unique type (or types) with the Sakai
structure, and associate its entities with the appropriate types.

Once the application puts an entity into the Sakai structure, the entity
can be the target of an authorization query.  This is very important!  If
the entity is not located in the structure, there is no way to check
authorizations against it!

There are other advantages of living in the structure (like aggregation),
and a few more things needed to fully participate in authorization (like
establishing a function / permission model), but this is a start.  Lets
revisit how the application responds to an interaction request, and how it
deals with the request context.

Imagine a simple application that shows an information display, and lets
authorized users edit it, not unlike syllabus or a simple wiki.  When this
application gets a request, it wants to respond by showing its information.
 It has a whole database of pages of information, each with a UUID.  But
which one should it use?

That's where the request context becomes useful.  When the application
processes the request, it gets the node that is the context, and asks the
Sakai structure for the information page, its own data entity, that is
located at (or near) that node.

Picture this:


[pic]


The node highlighted in the middle is the context of the request.

In this example, the node context of the request directly holds the
application's information page.  By asking the Sakai structure manager for
the entity of the type established for this entity, hanging off the request
context node, the application finds the data it needs to respond to the
request.
More accurately, the structure manager reports the UUID and type of the
entity hanging off the node.  The application is still responsible for the
management of its entities; is has only delegated the location within the
structure to the Sakai structure.

Applications will probably want the redundancy of a two-way association
with the structure, storing the entity's structure node address (UUID) as
part of the entity's data:

[pic]

The node's UUID never changes; even if the structure is re-organized, the
entity will still be associated with the same node (but be in a different
location).  Similarly, the entity's UUID never changes, so can be used by
the Sakai structure to refer to the entity.

The case where the request context node directly holds the entity will be
rare; it will be more likely that the entity will be held in a near child
of the context node:

[pic]


The top highlighted node is the request context.  In this case, the context
node does not have our entity.  It has a number of children, some
representing structure, others holding other types of entities for other
applications.  But one of the children has our information page.

The application finds this page by asking the Sakai structure manager for
the entity of the appropriate type hanging at or below the context node.

If it makes sense that the application has more than one instance of an
entity associated with the location, this can be represented like this:

[pic]

Another way to do this would be to use a containment node to organize the
similar entities, like this:

[pic]

To review:
    - an application must locate an entity in the Sakai structure
    - an application must register a type for each of its entities
    - location involves a node that knows the entity's type and UUID
    - location may also involve a containment node, with the entity nodes as
      children
    - the entity will probably store a back pointer to its location in the
      form of a node UUID
    - applications query the structure manager to find the entity or
      entities associated with a node, probably the request context node.



Finding Entities in the Sakai Structure / Aggregation


Sometimes an application is happy to just find the one or many entities
directly located at or below a node in the structure.  We covered how these
are found in the previous section.  But some applications will want to make
the structure more visible in their response.

Consider an application that will show the list of all of its entities
anywhere below the request context node.  The structure might look
something like this:

[pic]

An application that has simple aggregation would ask the structure manager
for all the entities anywhere below the context node, and display a list of
the 4 different information pages it finds.

The application might go further and make some of the Sakai structure
visible in its response.  Lets look again at the structure above, but this
time indicate some more details of the nodes and entities:

[pic]

Here, the node "name" is displayed instead of just "node", and the entities
have "names" as well ("1", "2", etc).  By asking the structure manager for
information about node children from the context node "A", and asking for
node traversal information as well, it could present a listing that groups
the entities by the node names and parent / child structure:

A pages:
    - page "1"
    - B pages:
         o page "2"
         o page '3"
         o C/D pages
               . Page "4"

Keep in mind that authorization is always in play - so if the user
generating the request does not have access to parts of the structure, or
to some of these entities, the set of information returned from the Sakai
structure will reflect this and be smaller.

Another form of aggregation that the application might do is like the one
just described, but larger.  In this mode, the application wants to show
all of the entities that the end user has access to, perhaps limited by
some area of the structure, or perhaps limited by some other search or
filtering criteria.  This is done is essentially the same way; the
application queries the structure manager for all entities of appropriate
type, with or without node traversal information as desired.  But this
time, the search starts at the top of the structure (or at some other high
point that expresses the part of the structure the application wishes to
search), rather than at just the request context node.  Further search or
filtering remains the responsibility of the application; the Sakai
structure does not understand the internal details of the entities it
places.


Delegating Containment to Sakai Structure


Most Sakai applications are more complex than our simple example.  Most
applications have some internal structure, organizing their entities in
some way.  These might form a hierarchy tree, as in Content Hosting, or
simply have a level of containment, as in the Message services (like
discussion, chat, email archive and announcement) with their message
channels.

It remains the responsibility of the application to model this structure,
and to expose this structure in their manager APIs and user interfaces.
But a well integrated, structure aware Sakai application will delegate the
implementation of these structuring needs to the Sakai structure manager,
and let the structure be represented as nodes in the structure.

The simple case has been covered in previous sections, that of placing an
entity into the structure at some location.  As mentioned, the application
will probably choose to locate entities under some containment node under
the context node, rather in the context node itself (a node can only have
one entity, but it can have many children; most context nodes will already
be holding an entity representing a class site, section, project, or some
other organizational entity).  This containment node is the perfect way to
model a collection or channel in the application:

[pic]


The channel node's entity is the application's channel object, properly
marked with the type the application has registered for its channels.  The
message nodes' entities are the application's message objects, also
properly typed.

The "channel" and "message" nodes are really just nodes; nothing special as
far as the Sakai structure is concerned.  They become special to the
application, and to any other structure user that examines the types of the
entities associated with the nodes.

A Content Hosting like application might have an internal tree structure.
Again, it will expose this in the APIs and user interfaces, but implement
it in the Sakai structure:

[pic]

This sort of structure would be found many places in the Sakai structure,
under many different nodes that are the navigation target of our end users
(i.e. nodes that represent classes, projects, sections, teams, user homes,
departments, etc).

To work with this structure, the application uses node traversal methods of
the structure API, such as "get a node's parent", "get a node's children",
"add a new child", etc.

Authorization and Structure


Authorization to access and processing of the application's entities is
still done using the basic security question: "can the current user perform
the requested activity on the indicated entity".  The application continues
to be responsible for providing "allow" methods, so security questions can
be asked of it, and for enforcing security at the deepest level (usually in
the application's manager, not the tools).  These are both done by asking
the authorization manager the basic security question.

The application has to establish a function or permission model.  This
involves creating a set of permissions specific to each activity that the
application needs to secure.  Rather than general permissions like "read"
or "write", the application should create specific functions for each
possible access.  This allows a fine-grained security model.

Authorizations are made by recording "grants", granting a user (or group) a
function (or set of functions) on the entities hanging at (or below) a node
in the strucure.

Grants flow "down" the Sakai structure.  Grants made against a node apply
to all the nodes below it in the structure.

[pic]


The grant applies to all the colored nodes.


To Be Continued.


More can and will be said about this, including:

    - Authorization Denys and Blocks
    - Application callback responsibilities
    - How a course, or project, or section looks in the structure
    - How course sectioning or project sub-grouping presents a very special
      case to handle


